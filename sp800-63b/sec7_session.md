<a name="sec7"></a>

## 7. Session Management

_This section is normative._

Once an authentication event has taken place, it is often desirable to allow the user to continue using the application across multiple subsequent interactions without requiring the user to repeat the authentication event every time. This requirement is particularly true for federation scenarios (described in [[SP 800-63C]](sp800-63c.html)), where the authentication event necessarily involves several components and parties coordinating across a network.

To facilitate this behavior, a *session* MAY be started in response to an authentication event, and continue the session until such time that it is terminated. The session MAY be terminated for any number of reasons, including but not limited to an inactivity timeout, an explicit logout event, or other means. The session MAY be continued through a reauthentication event (described in [Section 7.2](#sessionreauthn)), wherein the user repeats some or all of the initial authentication event, thereby re-establishing the session.

Session management is preferable over continual presentation of credentials as the usability requirements of continual presentation often create incentives for workarounds such as cached unlocking credentials, negating the freshness of the authentication event. 

### 7.1. Session Bindings

A session occurs between the software that a subscriber is running, such as a browser, application, or operating system (the session subject), and the RP or CSP that the subscriber is accessing (the session host). A session secret SHALL be shared between the subscriber's software and the service being accessed. This secret binds the two ends of the session, allowing the user to continue using the service over time. The secret SHALL be presented directly by the user's software or possession of the secret SHALL be proven using a cryptographic mechanism. 

The secret used for session binding SHALL be generated by the session host in direct response to an authentication event. A session SHOULD inherit the AAL properties of the authentication event which triggered its creation; a session MAY be considered at a lower AAL than the authentication event but SHALL NOT be considered at a higher AAL than the authentication event.

Secrets used for session binding: 

- SHALL be generated by the session host during an interaction, typically immediately following user authentication.
- SHALL be generated by an approved random bit generator and contain at least 64 bits of entropy.
- SHALL be erased or invalidated by the session subject when the user logs out.
- SHOULD be erased on the user endpoint when the user logs out or when the secret is deemed to have expired.
- SHOULD not be placed in insecure locations such as HTML5 Local Storage due to the potential exposure of local storage to XSS attacks.
- SHALL be sent to and received from the device using an authenticated protected channel.
- SHALL time out and not be accepted after the times specified in Sections [4.1.4](#aal1reauth), [4.2.4](#aal2reauth), and [4.3.4](#aal3reauth) (depending on AAL).
- SHALL not be available to insecure communications between the host and user endpoint; authenticated sessions SHALL not fall back to an insecure transport, such as from https to http, following authentication.

URLs or POST content SHALL contain a session identifier that SHALL be verified by the RP to ensure that actions taken outside the session do not affect the protected session.

There are several different mechanisms for managing a session over time. The following sections give different examples along with additional requirements and considerations particular to each example technology. Additional informative guidance is available in the OWASP *Session Management Cheat Sheet* [[OWASP-session]](#OWASP-session).

#### 7.1.1. Browser Cookies

Browser cookies are the predominant mechanism by which a session will be created and tracked for a user accessing a service. 

Cookies:

- SHALL be tagged to be accessible only on secure (HTTPS) sessions.
- SHALL be accessible to the minimum practical set of hostnames and paths.
- SHOULD be tagged to be inaccessible via JavaScript (HttpOnly).
- SHOULD be tagged to expire at or soon after the validity period of the session. This requirement is intended to limit the accumulation of cookies, but SHALL NOT be depended upon to enforce session timeouts.

#### 7.1.2. Access Tokens

An access token, such as found in OAuth, is used to allow an application to access a set of services on behalf of a user following an authentication event. The presence of an OAuth access token SHALL NOT be interpreted by the RP to indicate the presence of the user, in the absence of other signals. The OAuth access token (and any associated refresh tokens) MAY be valid long after the authentication session has ended and the user has left the application.

#### 7.1.3. Device Identification

Other methods of secure device identification, including but not limited to mutual TLS, token binding, or other mechanisms, MAY be used to enact a session between a user and a service. 

### 7.2. <a name="sessionreauthn"></a>Reauthentication 

Continuity of authenticated sessions SHALL be based upon the possession of a session secret issued by the verifier at the time of authentication and optionally refreshed during the session. The nature of a session depends on the application, including:

1. A web browser session with a "session" cookie, or
2. An instance of a mobile application that retains a session secret

Session secrets SHALL be non-persistent, i.e., they SHALL not be retained across a restart of the associated application or a reboot of the host device.

Periodic reauthentication of sessions SHALL be performed to confirm the continued presence of the subscriber at an authenticated session (i.e., that the subscriber has not walked away without logging out).

A session SHALL NOT be extended past the guidelines in Sections [4.1.3](#aal1reauth), [4.2.3](#aal2reauth), and [4.3.3](#aal3reauth) (depending on AAL) based on presentation of the session secret alone. Prior to session expiration, the reauthentication time limit SHALL be extended by prompting the subscriber for the authentication factor(s) specified in [Table 7-1](#63bSec7-Table1).

When a session has been terminated due to a time-out or other action, the user SHALL be required to establish a new session by authenticating again.

<a name="63bSec7-Table1"></a>

<div class="text-center" markdown="1">

**Table 7-1.  AAL Reauthentication Requirements**

</div>


|AAL|Requirement|
|----|----|
|1|Presentation of any one factor|
|2|Presentation of a memorized secret or biometric|
|3|Presentation of all factors|

>Note: At AAL2, a memorized secret or biometric and not a physical authenticator is required because the session secret is *something you have*, and an additional authentication factor is required to continue the session.

#### 7.2.1. Reauthentication from a Federation or Assertion

When using a federation protocol as described in [SP 800-63C Section 5](sp800-63c.html#federation) to connect the CSP and RP, special considerations apply to session management and reauthentication. The federation protocol communicates an authentication event between the CSP and the RP but establishes no session between them. Since the CSP and RP often employ separate session management technologies, there SHALL NOT be any assumption of correlation between these sessions. Consequently, when an RP session expires and the RP requires reauthentication, it is entirely possible that the session at the CSP has not expired and that a new assertion could be generated from this session at the CSP without reauthenticating the user.

An RP requiring reauthentication through a federation protocol SHALL, if possible within the protocol, specify the maximum acceptable authentication age to the CSP, and the CSP SHALL reauthenticate the subscriber if they have not been authenticated within that time period or if it is not specified. The CSP SHALL communicate the authentication event time to the RP to allow the RP to decide if the assertion is sufficient for reauthentication and to determine the time for the next reauthentication event.
